module OfflineMirror
  private
  
  class MirrorData
    attr_reader :group, :mode
    
    def initialize(group, data, app_mode = OfflineMirror::app_online? ? "online" : "offline")
      @group = group
      ensure_valid_mode(app_mode)
      @mode = app_mode
      
      # CargoStreamer
      @cs = case data
        when CargoStreamer then data
        when String then CargoStreamer.new(StringIO.new(data), "r")
        when Array then (
          data[0].is_a?(String) ? CargoStreamer.new(StringIO.new(data[0]), data[1]) : CargoStreamer.new(data[0], data[1])
        )
        else raise OfflineMirror::PluginError.new("Invalid data format for MirrorData initialization")
      end
    end
    
    def write_upwards_data
      # TODO : See if this can be done in some kind of read transaction
      write_data do
        add_group_specific_cargo(true)
      end
    end
    
    def write_downwards_data
      write_data do
        add_global_cargo
        
        # If this group has no confirmed down mirror, also include all group data to be the offline app's initial state
        if @group.group_state.down_mirror_version == 0
          add_group_specific_cargo
        end
      end
    end
    
    def load_upwards_data
      read_data_from("offline") do
        import_group_specific_cargo
      end
    end
    
    def load_downwards_data
      read_data_from("online") do
        group_cargo_name = data_cargo_name_for_model(OfflineMirror::group_base_model)
        if @cs.has_cargo_named?(group_cargo_name)
          # Read the initial down mirror data, if available.
          # This is done after import_global_cargo because group data might belong_to global data.
          OfflineMirror::SystemState::create(
            :current_mirror_version => 1,
            :offline_group_id => @cs.first_cargo_element(group_cargo_name).id
          ) or raise PluginError.new("Cannot load initial down mirror file")
          import_global_cargo
          import_group_specific_cargo
        elsif SystemState.count == 0
          # If there's no SystemState, then we can't accept non-initial down mirror files
          raise DataError.new("Initial down mirror file required")
        else
          import_global_cargo
        end
      end
    end
    
    private
    
    def data_cargo_name_for_model(model)
      "data_#{model.name}"
    end
    
    def write_data
      # TODO : See if this can be done in some kind of read transaction
      @cs.write_cargo_section("mirror_info", [MirrorInfo.new_from_group(@group, @mode)], :human_readable => true)
      @cs.write_cargo_section("group_state", [@group.group_state], :human_readable => true)
      yield
    end
    
    def read_data_from(expected_source_app_mode)
      raise DataError.new("Invalid mirror file, no info section found") unless @cs.has_cargo_named?("mirror_info")
      unless @cs.first_cargo_element("mirror_info").app_mode.downcase == expected_source_app_mode.downcase
        raise DataError.new "Mirror file was generated by app in wrong mode; was expecting #{expected_source_app_mode}"
      end
      
      OfflineMirror::group_base_model.connection.transaction do
        yield
      end
    end
    
    def ensure_valid_mode(mode)
      raise PluginError.new("Invalid app mode") unless ["online", "offline"].include?(mode)
    end
    
    def add_group_specific_cargo(include_deletions = false)
      # FIXME: Test that when this is called by the online app, it doesn't put group-specific junk in sendable_records
      OfflineMirror::group_owned_models.each do |name, cls|
        add_model_cargo(cls, include_deletions, "#{cls.offline_mirror_group_key.to_sym} = #{@group.id}")
      end
      add_model_cargo(OfflineMirror::group_base_model, false, "id => #{@group.id}")
    end
    
    def add_global_cargo(include_deletions = true)
      OfflineMirror::global_data_models.each do |name, cls|
        add_model_cargo(cls, include_deletions)
      end
    end
    
    def add_model_cargo(model, include_deletions, model_condition = "")
      # TODO: Check against mirror version
      model_state = ModelState.find_or_create_by_model(model)
      model_condition = "#{model.table_name}.#{model_condition}" unless model_condition == ""
      SendableRecordState.find_in_batches(
        :conditions => (
          ["model_state_id = #{model_state.id}"] +
          (model_condition != "" ? [model_condition] : []) +
          (include_deletions ? [] : ["local_record_id != 0"])
        ),
        :joins => "LEFT JOIN #{model.table_name} ON local_record_id = #{model.table_name}.id",
        :batch_size => 100
      ) do |batch|
        @cs.write_cargo_section(data_cargo_name_for_model(model), batch)
      end
    end
    
    def import_group_specific_cargo
      import_model_cargo(OfflineMirror::group_base_model)
      OfflineMirror::group_owned_models.each do |name, cls|
        import_model_cargo(cls)
      end
    end
    
    def import_global_cargo
      OfflineMirror::global_data_models.each do |name, cls|
        import_model_cargo(cls)
      end
    end
    
    def import_model_cargo(model, options = {})
      @cs.each_cargo_section(data_cargo_name_for_model(model)) do |batch|
        batch.each do |cargo_record|
          # Remember: Their remote id is our local id, and vice versa
          if cargo_record.local_record_id == 0
            # This record no longer exists there, so let's destroy it here too
            model.find(cargo_record.remote_record_id).destroy
          else
            # Update/create the record here to match the record there
            db_record = cargo_record.remote_record_id != 0 ? model.find(cargo_record.remote_record_id) : Model.new
            db_record.bypass_offline_mirror_readonly_checks
            db_record.attributes = cargo_record.send(model.table_name.to_sym).attributes
            db_record.save!
            
            # If this record is just being created here now, update the state with the source's id number
            # TODO: Also do this upon receiving confirmation that it was created at the other side
            # TODO: Might be able to optimize this so there's only one save per SRS instead of two
            if cargo_record.remote_record_id == 0
              SendableRecordState.note_record_has_remote_id(db_record, cargo_record.local_record_id)
            end
          end
        end
      end
    end
  end
end