- Use transactions for mirror load operations
- Creating/updating the installer (ideally, git to target platform, one rake task, then upload back to original server)
- Intercept group deletions, drop corresponding group_state
- When processing migrations, watch for table drops and renames; do corresponding change in table_states
- When applying upmirror files, use all supplied permission checks and also check to make sure object being changed belongs to logged-in user's group
- The launcher should keep a log file
- Include recent log lines (for both Rails and the launcher) in generated up-mirror files, for debugging purposes
- Use rails logger to note activity
- Document that the id of the group model itself is _never_ transformed, but all group_owned models and global models do have their id's transformed
- Scenario to deal with: offline app applies an initial down mirror, then makes local changes, then attempts to reapply _another_ initial down mirror
 - To deal with this, just ignore all non-global records in the second initial down mirror, since they should be identical
- Scenario to deal with: offline app creates an up-mirror, makes local changes, then up-mirror is applied and confirmed. Are local changes version-lost?
- Versioning the app : how to do this?
- When we import first down mirror w/ group data, set current_mirror_version to up_mirror_version + 1. SystemState::get tries to do this; test.
- At offline app: When an up-mirror of a given version is confirmed, increment current_mirror_version. Complain if confirmation is not on current version.
- At online app: When a down-mirror of a given version is confirmed, delete all sendable_records entries for deletions older than min(down_version)
- Make sure the filters catch typical ActiveRecord class methods: create, update, delete, etc.
- Split the offline environment into 'offline-production' and 'offline-test'
- Only update current_mirror_version after a confirmed transfer; that way, if 1st mirror file generated is lost, no big deal
- Don't accept down-mirror or up-mirror files that are the same version as the one already in place; version number must be greater
 - This causes problems if we aren't getting a nice back-and-forth of up-mirror and down-mirror, which is intentional
- In online app, increment current_mirror_version whenever anyone confirms that they received a down mirror
- In offline app, increment current_mirror_version whenever an up-mirror is confirmed
- In documentation, note that migrations which change records' primary keys will break synchronization
- Try to gather some kind of machine identifier to put in up-mirror information, so admins can know when there's more than one offline setup for a group
- Add a comment to generated migrations letting the app developer know about stuff they need to be careful of due to Offline Mirror
- Try streaming out with large data sets and make sure it is sufficiently speedy, and is actually streaming (i.e. no Content-Length header)
- Make extra sure to check that I'm not encoding ActiveRecord instances in cargo
- When transforming primary keys, also transform foreign key columns
