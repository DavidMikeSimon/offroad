- Use transactions for mirror load operations
- Creating/updating the installer (ideally, git on target platform, one rake task, then upload back to original server)
- Intercept group deletions, drop corresponding group_state
- When processing migrations, watch for table drops and renames; do corresponding change in table_states
- When applying upmirror files, use all supplied permission checks and also check to make sure object being changed belongs to logged-in user's group
- The launcher should keep a log file
- Include recent log lines (for both Rails and the launcher) in generated up-mirror files, for debugging purposes
- Use rails logger to note activity
- Document that the id of the group model itself is _never_ transformed, but all group_owned models and global models do have their id's transformed
- Versioning the app : how to do this?
- When we import first down mirror w/ group data, set current_mirror_version to up_mirror_version + 1. SystemState::get tries to do this; test.
- At offline app: When an up-mirror of a given version is confirmed, increment current_mirror_version. Complain if confirmation is not on current version.
- At online app: When a down-mirror of a given version is confirmed, delete all sendable record state entries for deletions older than min(down_version)
- Make sure the filters catch typical ActiveRecord class methods: create, update, delete, etc.
- Only update current_mirror_version after a confirmed transfer; that way, if 1st mirror file generated is lost, no big deal
- Don't accept down-mirror or up-mirror files that are the same version as the one already in place; version number must be greater
 - This causes problems if we aren't getting a nice back-and-forth of up-mirror and down-mirror, which is intentional
- In online app, increment current_mirror_version whenever anyone confirms that they received a down mirror
- In offline app, increment current_mirror_version whenever an up-mirror is confirmed
- In documentation, note that migrations which alter records' primary keys, or change model names, will break synchronization. Table name changes are fine.
- Try to gather some kind of machine identifier to put in up-mirror information, so admins can know when there's more than one offline setup for a group
- Add a comment to generated migrations letting the app developer know about stuff they need to be careful of due to Offline Mirror
- Try streaming out with large data sets and make sure it is sufficiently speedy, and is actually streaming (i.e. no Content-Length header)
- When transforming primary keys, also transform foreign key columns
- Change mime-type of mirror files to something that doesn't allow it to be accidentally viewed in-browser
- Use md5sum on the entire cargo file instead of just each individual part, to protect against corruption outside the actual data segments
- Use signatures to verify that the cargo file came from where it was supposed to
- Consider paginating cargo by byte size instead of in fixed-length batches
- Consider using activerecord-import, if available, to speed up insertions
- An emergency mirror file generation mode, which includes all records instead of just updates (and has no deletion records)
- Should split MirrorData into MirrorDataWriter and MirrorDataReader
- Be sure to make an integration test for populating an empty offline app from initial down mirror file
- Remove offline_group_id system setting; don't really need it, since there should only be one group record
  - On that note, in offline app ensure that there is only one group record
- When loading records, add higher records first (that is, the records that lower records belong_to)

- Scenario to deal with: offline app applies an initial down mirror, then makes local changes, then attempts to reapply _another_ initial down mirror
 - To deal with this, just ignore all non-global records in the second initial down mirror, since they should be identical
- Scenario to deal with: offline app creates an up-mirror, makes local changes, then up-mirror is applied and confirmed. Are local changes version-lost?
- Scenario to deal with: offline app reverts to a prior backup, and prior backup either:
	- Has the same mirror version as online, or
	- Has prior version to online, or
	- Has newer version than online (this shouldn't require any special handling...)
- Scenario to deal with: offline app loses its offline_mirror_* table
	- It should be possible to handle this case by just sending out an up-mirror file that solicits an initial down-mirror file
