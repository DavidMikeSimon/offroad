- Figure out why the test app won't generate initial down mirror files with cache_classes = false
- Get the plugin installer to work well
- Allow offline app to request group be made online in its up mirror file
  - This is the best way to ensure we don't have un-sendable records left over in a newly-obsolete offline app
- Assign a random number to group state when it is created, only accept mirror files with matching random number
  - This is to prevent confusion if a group is made offline, then online, then offline again
- Also assign a random number to the online app, and only accept mirror files which match this number as well
  - Prevents multiple installations of an app from reading each others' mirror files
- Use read transactions for mirror write operations (is it already doing this?)
- Creating/updating the installer (ideally, git pull on target platform, one rake task, then git push)
  - Alternately, see if it can be created on-the-fly. EEE just uses appended data, right?
- When processing migrations, watch for table drops and renames; do corresponding change in table_states
- When applying upmirror files,  make sure object being changed belongs to logged-in user's group
- The launcher should keep a log file
- Include recent log lines (for both Rails and the launcher) in generated up-mirror files, for debugging purposes
- Use rails logger to note activity
- Versioning the app : how to do this?
- When mirror data version is confirmed, delete all sendable record state entries for deletions older than min(version) over all group_states
- In documentation, note that migrations which alter records' primary keys, or change model names, will break synchronization. Table name changes are fine.
- Try to gather some kind of machine identifier to put in a offline-owned group_state column, so admins can know when there's more than one offline setup for a group
- Try streaming out with large data sets and make sure it is sufficiently speedy, and is actually streaming (i.e. no Content-Length header)
- Change mime-type of mirror files to something that doesn't allow it to be accidentally viewed in-browser
- Use md5sum on the entire cargo file instead of just each individual part, to protect against corruption outside the actual data segments
- Consider using activerecord-import, if available, to speed up insertions
- Allow app to optionally specify batch sizes on a model-by-model basis
- Mirror file imports in the down mirror app should happen through GUI, and GUI should delete files once succesfully imported
- If offline app attempts to import a down mirror file and it doesn't work, it should:
  - Delete the down mirror file as usual, but...
  - Explain that it wasn't imported and that another down mirror file should be deleted
- Figure out which activerecord methods skip the save callbacks, and wrap them to also update the mirror version
- Load all the other informational values in GroupState
- Use ActiveRecord reflections to find belongs_to associations, not the currenty hacky belongs_to wrapper
- Use save(false) to skip validations, not save_without_validations

Scenarios to deal with:

- Offline app creates an up-mirror, makes local changes, then up-mirror is applied and confirmed. Are local changes version-lost?
- Offline app reverts to a prior backup, and prior backup either:
	- Has the same mirror version as online, or
	- Has prior version to online, or
	- Has newer version than online (this shouldn't require any special handling...)
- Turning an online app into an offline app, then online again, then offline again, with data xfer happening at each stage
- Online app receives a mirror file, then offline updates and sends another mirror file, without receiving confirmation of first
- Offline app attempts to delete offline group on online app: this should not be possible
- App creates a record then deletes it then sends mirror; does a deletion srs still get sent?
  - For any fix to this: make sure that if app updates record then deletes it then sends mirror that deletion gets sent
  - Maybe that means we need both create_version and update_version on srs?
